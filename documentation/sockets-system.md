# Chess Sockets System

## Table of Contents

 1. [Basic information](#1-basic-information)
 2. [Basic principles of Connections System](#2-basic-principles-of-connections-system)
 3. [Basic principles of Invitations system](#3-basic-principles-of-invitations-system)
 4. [Basic principles of Game system](#4-basic-principles-of-game-system)
 5. [Application namespaces](#5-application-namespaces)
 6. [Chat](#6-chat)
 7. [Security](#7-security)


## 1-Basic information
- Сокети в даній аплікації *(nodejs-chess)* потрібні виключно для надсилання повідомлень від **сервера** до **клієнта**, тобто вони працюють лише в одному напрямку *(за виключенням стартового handshake, під’єднання до особистої кімнати, //та чату???)*.  

  Тобто **сервер** буде ігнорувати будь-які повідомлення **клієнта** окрім `connection` та `join`. 
> *// Вияснити з чатом*

- Передача усіх даних на **сервер** (ходів гравців, запрошень і тд.) буде здійснюватися за допомогою протоколу **HTTP**.




## 2-Basic principles of Connections System

- Кожен  користувач при реєстрації отримує унікальний ідентифікатор для його особистої кімнати:  
  `userRoom: { type: String }`  

  *(Це символьна стрічка вигляду  `'30b4ac09...'`, згенерована випадковим чином на основі унікального імені користувача + поточного часу та захешована за допомогою алгоритму md5 )*  

  Ця кімната потрібна для того, щоб у випадку авторизації/входу користувача під своїм іменем з кількох вкладок/пристроїв, він все рівно зміг отримувати повідомлення на кілька вкладок/пристроїв.  
В даному випадку до кімнати користувача буде під'єднано кілька різних сокетів *(з різними id)*, але через те, що вони будуть під'єднані до однієї кімнати *(socket room `'30b4ac09...'`)*, повідомлення для користувача одночасно будуть надходити на всі клієнтські під'єднані вкладки/пристрої.
- Коли аплікація стартувала, і користувач авторизувався, тоді на фронтенді контролер сторінки `.../playersRoom/`  (не плутати з кімнатами для сокетів) звертається до API для отримання ідентифікатора кімнати за адресою `.../api/user/room/`  
> // Може його зразу відсилати при успішній авторизації? Якшо та, то треба придумати де його зберігари, щоб всі контролери мали до нього доступ.

- Коли ідентифікатор отриманий, користувач за допомогою сокета через простір імен `'/game'` *(про простори імен див.  П.5)* надсилає запит на під’єднання до своєї кімнати, у повідомленні він додає  ідентифікатор цієї кімнати, щоб сервер додав даний сокет в цю кімнату:  
`emit('join', {room: '30b4ac09...'})`.
- Якщо в кімнаті користувача є як мінімум **один** сокет, тоді статус користувача змінюється на `'online'`.
- Якщо користувач з якихось причин виходить з кімнати (зв'язок перервався, закрилася вкладка, //**_час сесії вийшов??? вияснити!_**) тоді сервер перевіряє чи дана кімната пуста, якщо так, тоді статус користувача змінюється на `'offline'`.  
Якщо кімната не пуста, це означає, що на іншій вкладці/пристрої є активний сокет, тому користувач залишається в статусі  `'online'`.


> *// При пустій кімнаті під час гри тут певно треба буде послати повідомлення користувачу що суперник оффлайн і заморозити гру??? І треба продумати всі випадки з непустою кімнатою....*
>  
> *// Що робити коли для одного користувача на одному пристрої час одної сесії вийшов, а на іншому пристрої/браузері інша сесії ще активна?*
>  
> *// Та і взагалі як саме міняти статуси коли час сесії закінчився*

### Оновлення списку користувачів при підключенні/відключенні нового користувача
- При першому запиті сторінки `.../playersRoom/` список користувачів, які зараз в статусі  `online` завантажується звідси:`/api/users-online/`
- Всі наступні сповіщення про вхід/вихід нових користувачів відбувається через повідомлення сокетів: 
  - **Server:**  
`socketsManager('/game').emit('newUser', {username: ... , userId: ... });`  
`socketsManager('/game').emit('removeUser', userId);`
   - **Client:**  
`gameSocket.on('newUser', ... );`  
`gameSocket.on('removeUser', ... );`

> *Треба придумати як відправити усім кімнатам в неймспейсі*
> 
> *Треба придумати, чи відправляти користувачу ім’я та id нового користувача, чи тільки id, а контролер хай сам підтягує з сервера всю іншу інфу типу Ім'я чи нікнейм, аватарку і тд...*


## 3-Basic principles of Invitations system
В базі даних в документі користувача зберігається масив відправлених та отриманих запрошень `(incoming & outgoing іnvitations)`.  
*(Для того щоб при перезавантаженні сторінки чи обриву зв'язку і реконнекті цей список можна було відправити користувачу знову.)* 

`incomingInvitations: [ {from: userId, timeStamp: time}, ...]`  
`outgoingInvitations: [ {to: userId, timeStamp: time}, ...]`

 
### Відправлення запрошення супернику
- `/api/user/invitation/send/:opponentID`
- **Server:**  
`socketsManager('/game').to(userRoom).emit('incomingInv', {userName: ..., userId: ...});`
- **Client:**  
`gameSocket.on('incomingInv', ... );`

### Скасування запрошення супернику
- `/api/user/invitation/cancel/:opponentID`
- **Server:**  
`socketsManager('/game').to(userRoom).emit('cancelInv', userId);`
- **Client:**  
`gameSocket.on('cancelInv', ... );`

### Прийняття запрошення
- `/api/user/invitation/accept/:opponentID`  
*Далі див пункт 3 - Game system*

### Відхилення запрошення
- `/api/user/invitation/reject/:opponentID`
- **Server:**  
`socketsManager('/game').to(userRoom).emit('rejectInv', userId);`
- **Client:**  
`gameSocket.on('rejectInv', ... );`


>  // При запиті для прийняття запрошення користувачем (на сервері) треба буде перевіряти чи суперник онлайн. Бо він міг відправити запрошення і після цього зв'язок міг обірватися.
>   
>  // В API треба додати методи, які б повертали списки вхідних та вихідних запрошень, та додати відповідні методи для їх запитів в контролер.
>   
>  // Ідеально би було, як би запрошення мали термін дії (наприклад, 10 хв) та обмеження на максимальну кількість(наприклад, максимум 15 запрошень). Тобто, якщо запрошення протягом 10 хв ніхто не прийняв - автоматично його видаляти. Але то таке, на майбутнє :)
>   
>  // Також при прийнятті запрошення варто було б відхилити запрошення усіх інших користувачів.
>   
>  // І треба подумати, що буде на даній вкладці, коли на іншій запрошення відхилиться... чи ну нафіг то всьо синхронізувати?

## 4-Basic principles of Game system


### Отримання повідомлення про старт гри.
Коли користувач прийняв запрошення від певного користувача, на сервері відбуваються наступні дії:

- Витягаємо id обох гравців.
- Створюємо об’єкт гри, в який записуємо id гравців, і ше шо нам треба.
- Беремо з БД ідентифікатори (userRoom) кімнат обох користувачів, і кожному відпавляємо повідомлення.
- **Server:**  
`socketsManager('/game').to(userRoom).emit('startGame', gameId);`  
**Client:**  
`gameSocket.on('startGame', ... );`
> *// Треба подумати, чи відправляти лише id гри чи відправляти одразу цілий об'єкт гри, щоб не робити зайвого запиту за рештою даних?*

- Змінюємо статуси обох користувачів на `in_game`.
- При отриманні на клієнті повідомлення `'startGame'`, потрібно записати в сервіс  GameService ідентифікатор гри (id), та змінити location на `.../game` чи `.../board` де стартує сервіс гри який всьо рішає :)

###Обмін ходами.

- спочатку відправляємо запит на сервер
`/api/game/move/`
В який потрібно включити id гри, та сам хід, наприклад: 
`{gameId: id, from: 'A2', to: 'A4'}`
> *//Треба узгодити чи `GET` чи `POST`, і якщо `GET`, то в якому форматі передавати параметри.*

- Якщо сервер провів валідацію даного ходу та заберіг хід у базу даних, то  гравець отримує `response` з підтвердженням ходу, і переставляє фігуру в себе, а супернику надсилається повідомлення про хід через сокет.
> *// Треба добре обдумати, чи поки не пройде оцей весь цикл переставляти фігуру в користувача, який зробив хід, чи дочекатися відповіді сервера, і тоді переставити?*

- Повідомлення для суперника:  
**Server:**  
`socketsManager('/game').to(userRoom).emit('movePiece', {gameId: id, from: 'A2', to: 'A4'});`
> *// Узгодити, чи треба відправляти id гри, бо теоретично треба, якщо раптом буде функціональніість для участі у кількох іграх одночасно...*  

  **Client:**
`gameSocket.on('movePiece', ... );`

> ***!!! Треба придумати чи треба таку штуку, як заборона ходів гравця поки суперник не походив. Тобто забезпечити почерговість ходів.!!!***
>  
> *// Треба ше придумати, шо буде коли під час гри ми рефрешнемо сторінку. Напевно треба в контролері дошки передбачити, що як тільки контролер починає працювати, він за допомогою сервісу для гри чекає чи часом в користувача немає незавершених активних ігор, і якщо є, то послати запис на сервер, щоб сервер у відповідь надіслав об’єкт гри, в якому буде масив з зробленими ходами, і тоді згодувати ці ходи абстрактній дошці, і тоді на основі того оновити відображення на UI.*
>  
>  *Це треба узгодити з пунктом про старт гри, можливо вдасться зробити його універсальним. Тобто при старті гри відсилати тільки id гри, а сервіс тоді буде надсилати запит на серве для отриманні інформації про гру по даному id. Якщо масив ходів буде пусти, то тоді ініціалізувати нову гру, якщо списко не пустий, то див вище :)*

## 5-Application namespaces
* `'/general'` - для оновлення таблиці рекордів онлайн (подумати чи треба?).
* `'/game'` - для отримання запрошень, оновлення списку користувачів, старту нової гри та отримання інформації про ходи суперника.
* `'/chat'` - в цьому нейспейсі будуть кімнати для чатів.  
Наприклад кімната 'generalChatRoom' (якщо потрібно буде загальний чат на сторінці /playersRoom) та кімнати для кожної гри (назви кімнат треба буде генерувати при створенні гри та записувати в об’єкт гри, який буде розсилатися користувачам у випадку прийнятого запрошення).

## 6-Chat
> *//подумати над концепцією, і чи буде дана система з неймспейсами та кімнатами scaleble для чату?*
> 
> *// якщо так, то яким чином можна буде реалізувати загальний чат та чат по кімнатах для кожної гри, і підключити сюди того, хто буде займатися чатами, якщо вони таки будуть.*

## 7-Security
Теоретично, проблем з безпекою не повинно бути, тому що для отримання ідентифікатора кімнати потрібно бути авторизованим. Також через сокет максимум можна отримати 

- дані про користувачів онлайн (їхні імена та id), 
- повідомлення про старт гри та id цієї гри, 
- інформацію про ходи суперника. 

Відправити через сокети ми не зможемо нічого, а щоб відправити запрошення чи зробити хід через HTTP маючи id користувача чи id гри - потрібно бути авторизованим.

> Для того щоб авторизуватися нам потрібно разом з запитом відправити session id, який збережений в cookies, і він є HTTP only і ми не зможемо його прочитати напряму з javaScript-та. А перехопити?
